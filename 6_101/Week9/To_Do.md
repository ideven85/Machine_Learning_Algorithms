Hopefully this has been a useful example, demonstrating not only a little bit about how classes work but also how we can use them (and, in particular, use inheritance) to help us avoid repetitious or overly complex code. We'll leave that last example as our ending point for the day, but there are lots of things that we could still do to improve on this code! If you have the time and interest, it might be fun to tackle any of the following additions/improvements (or others of your own devising):
* Even though we were able to move some redundant code from Union, Intersection, and Difference into the Combination class, there is still a lot of similarity in their __contains__ methods. Try finding a way to move the common behavior from their __contains__ methods into the Combination class without resorting to explicit checking of types anywhere.
* Add support for built-in operations to create combinations. For example, s1 | s2 could result in Union(s1, s2), and we could do similar things for the other combinations. How can we accomplish this, and in which classes should the associated methods be implemented?
* Make more kinds of primitive shapes (how could you implement a triangle? an octagon? etc?).
* Make a new kind of shape representing an outline of a given shape, so that Outline(s, w), for example, would be a new shape that contains pixels that are within w pixels of the edge of an abitrary shape s. This can be done purely in terms of s.__contains__, without needing to store any additional information in s.
* Implement one or more "transformations" of shapes, for example:
    * Scaled(s, n) could be a version of s scaled up in size by a factor of n.
    * Rotated(s, d) could be a version of s rotated by d degrees about its center.
    * Translated(s, dx, dy) could be a version of s moved through space by dx pixels horizontally and dy pixels vertically.
* Use the shapes library you've written to draw cool pictures!
* Our draw code is inefficient because it iterates over every pixel of an image to find which pixels we should draw for a specific Shape. Typically, the shapes are much smaller than the entire image. Implement the notion of a bounding box, namely the smallest Rectangle that includes all the pixels of a Shape. With this, re-write draw to make use of the bounding box so that only the pixels within it need to be scanned to see which are actually in the shape and thus which need to be drawn onto the image.
If you take on any of these tasks, we'd be interested to hear about them (and/or to help you get them to work if you're having trouble!).